# 12. Навигация по фрагментам

* Фрагменты предназначены быть автономными составными единицами. Если вы пишете фрагмент, который добавляет фрагменты во FragmentManager activity, то этот фрагмент «предполагает», как работает хост-activity, и больше не является самостоятельной единицей.

* Для сохранения независимости ваших фрагментов вы будете делегировать работу обратно в хост-activity, определяя во фрагментах интерфейсы обратного вызова. Хост-activity реализует эти интерфейсы для выполнения задач по надзору за фрагментами и поведения, зависящего от компоновки.

## **Интерфейсы обратного вызова фрагментов**

* Для передачи функциональности обратно хостингу в фрагменте обычно **определяется пользовательский интерфейс обратного вызова под именем Callbacks**. Этот интерфейс определяет работу, которую должна выполнить хост-activity. Любая activity, которая будет содержать фрагмент, должна реализовывать этот интерфейс.

* С помощью интерфейса обратного вызова фрагмент способен вызывать функции, связанные с его хост-activity, без необходимости знать что-либо о том, какая activity является хостом.

* Функция жизненного цикла
Fragment.onAttach(Context) вызывается, когда фрагмент прикреплется к activity

* Activity является подклассом Context, поэтому функция onAttach(...) передает в качестве параметра объект Context, который более гибок.

* CrimeListFragment выполняет неконтролируемую передачу своей activity в CrimeListFragment.Callbacks. Это означает, что хост-activity должна реализовывать функцию CrimeListFragment.Callbacks. Это правильная зависимость, но важно ее задокументировать.

---

## **Замена фрагмента**

* Функция **FragmentTransaction.replace(Int,Fragment)** заменяет фрагмент, размещенный в activity (в контейнере с указанным целочисленным идентификатором ресурса), на новый фрагмент. Если фрагмент еще не размещен в указанном контейнере, то добавляется новый фрагмент, как если бы вы вызвали **FragmentTransaction.add(Int,Fragment)**.

---

## **Аргументы фрагментов**

* Аргументы фрагментов позволяют хранить фрагменты данных в том месте, которое принадлежит фрагменту. Это самое место называется пакетом аргументов. Фрагмент может получить данные из пакета аргументов, не полагаясь на свою родительскую activity или другой внешний источник.

* Чтобы присоединить пакет аргументов к фрагменту, вызовите функцию **Fragment.setArguments(Bundle)**. Присоединение должно быть выполнено после создания фрагмента, но до его добавления в activity.

* Для этого программисты Android используют схему с добавлением в класс Fragment статической функции newInstance(...). Эта функция создает экземпляр фрагмента, упаковывает и задает его аргументы.

---

## **Получение аргументов**

* Когда фрагменту требуется получить доступ к его аргументам, он ссылается на свойство arguments класса Fragment, а затем один из геттеров Bundle для конкретного типа.

---

## **Преобразования LiveData**

* ViewModel-и никогда не должны выставлять публично MutableLiveData.

* Что именно в CrimeDetailViewModel отслеживает изменения значения приватного идентификатора? Ответ заключается в операторе **Transformation (преобразование)**. **Преобразование данных в реальном времени** — это способ установить отношения «триггер — ответ» между двумя объектами LiveData. Функция преобразования принимает два объекта: объект LiveData, используемый в качестве триггера, и функцию отображения, которая должна вернуть объект LiveData. Функция преобразования возвращает новый объект LiveData, который мы называем результатом преобразования, значение которого обновляется каждый раз, когда изменяется значение триггерного объекта LiveData.

* **View.jumpDrawablesToCurrentState()** - пропустить анимацию у checkbox, когда вы программно устанавливаете флажок

---

## **Обновление базы данных**

* Room автоматически выполняет запросы к базе данных в фоновом потоке, потому что эти функции DAO возвращают LiveData. В этих случаях LiveData обрабатывает пересылку данных и отправляет в ваш основной поток, чтобы вы могли обновить ваш пользовательский интерфейс.

* Однако Room не будет автоматически запускать взаимодействие с базой данных для выполнения вставки и обновления. Вместо этого вам нужно будет явно выполнить вызовы DAO. Обычный способ сделать это — **использовать исполнителя**.

---

## **Использование исполнителя**

* **Исполнитель** — это объект, который ссылается на поток. Экземпляр исполнителя имеет функцию, называемую **execute**, которая принимает на выполнение блок кода. Код, который находится в этом блоке, **будет выполняться в любом потоке, на который ссылается исполнитель**.

* **Функция newSingleThreadExecutor()** возвращает экземпляр исполнителя, который указывает на новый поток. Таким образом, любая работа, которую вы выполняете с исполнителем, будет происходить вне основного потока.

---

## **Привязка записи в базу данных к жизненному циклу фрагмента**

* **Функция Fragment.onStop()** вызывается всякий раз, когда ваш фрагмент переходит в состояние остановки (то есть всякий раз, когда фрагмент оказывается вне поля зрения).

---

## **Для любознательных: зачем использовать аргументы фрагментов?**

* В этой главе мы добавили во фрагмент функцию **newInstance(...)** для передачи аргументов при создании нового экземпляра фрагмента. Этот шаблон не только полезен с точки зрения организации кода, но и необходим в случае использования аргументов фрагмента. Нельзя использовать конструктор для передачи аргументов экземпляру фрагмента.

* Например, можно рассмотреть возможность добавления в CrimeFragment однопараметрического конструктора, ожидающего идентификатор преступления, вместо добавления функции newInstance(UUID). Однако это плохой подход. **При изменении конфигурации менеджер фрагментов текущей activity автоматически заново создает фрагмент, который был размещен до изменения конфигурации. Затем менеджер фрагментов добавляет этот новый экземпляр фрагмента в новую activity**.

* Когда менеджер фрагментов заново создает фрагмент после изменения конфигурации, получается беспараметрический конструктор фрагмента по умолчанию. Это означает, что **после поворота новый экземпляр фрагмента не будет получать идентификатор преступления**.

* Так чем же отличаются аргументы фрагмента? **Аргументы фрагментов сохраняются после уничтожения фрагмента**. Менеджер прикрепляет аргументы к новому фрагменту, который он создает заново после поворота. Затем этот новый фрагмент может использовать пакет аргументов для воссоздания своего состояния.

* Почему бы просто не задать переменную экземпляра в CrimeFragment при создании?
Потому что такое решение будет работать не всегда. **Когда ОС создает заново ваш фрагмент (либо вследствие изменения конфигурации, либо при переходе пользователя к другому приложению с последующим освобождением памяти ОС), все переменные экземпляров теряются**. Также помните о возможной нехватке памяти.

* Один из возможных вариантов — **использование механизма сохранения состояния экземпляров**. Идентификатор преступления заносится в обычную переменную экземпляра, сохраняется вызовом onSaveInstanceState(Bundle), а затем извлекается из Bundle в onCreate(Bundle?). Такое решение будет работать всегда.

* С другой стороны, оно усложняет сопровождение. Если вы вернетесь к фрагменту через несколько лет и добавите еще один аргумент, нельзя исключать, что вы **забудете сохранить его в onSaveInstanceState(Bundle)**. Смысл этого решения не столь очевиден.

* Разработчики Android предпочитают решение с аргументами фрагментов, потому что в этом случае они предельно явно и четко обозначают свои намерения. Через несколько лет вы вернетесь к коду и будете знать, что идентификатор преступления — это аргумент, который надежно передается новым экземплярам этого фрагмента. При добавлении нового аргумента вы знаете, что его нужно сохранить в пакете аргументов.

---

## **Для любознательных: библиотека компонентов архитектуры навигации**

* Стремясь упростить навигацию в приложениях, команда разработчиков Android создала библиотеку компонентов архитектуры навигации в составе Jetpack. Эта библиотека упрощает реализацию навигации, в ней есть графический редактор, позволяющий настроить поток навигации 

* Библиотека Navigation предвзято относится к вопросу о том, как вам следует реализовывать навигацию в вашем проекте. В ней предпочтение отдается навигации по фрагментам с одной activity. Аргументы, необходимые фрагментам, вы можете передавать средствами редактора навигации.

---

## **Дополнительно про RecyclerView**

* ListAdapter — это RecyclerView.Adapter, который определяет разницу между текущим и новым набором данных и который вы задаете сами. Сравнение происходит в фоновом потоке, поэтому оно не замедляет работу пользовательского интерфейса. Адаптер ListAdapter, в свою очередь, дает команду утилизатору перерисовывать только измененные строки.

* В ListAdapter используется androidx.recyclingerview.widget.DiffUtil для определения того, какие части набора изменились. 

* Чтобы отправлять обновленный список преступлений в адаптер утилизатора, а не переназначать адаптер каждый раз, когда захотите обновить пользовательский интерфейс, вы можете отправить новый список, вызвав функцию ListAdapter.submitList(MutableList<T>?), или вы можете настроить LiveData и наблюдать за изменениями.

* См. справку по API для androidx.recyclingerview.widget.DiffUtil и androidx.recyclingerview.widget.ListAdapter на developer.android.com/reference/kotlin для получения более подробной информации о том, как использовать эти инструменты.