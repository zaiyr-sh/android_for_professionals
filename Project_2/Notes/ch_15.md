# 15. Неявные интенты

* **В Android можно запустить activity из другого приложения на устройстве при помощи неявного интента (implicit intent)**. В явном интенте (explicit intent) задается класс запускаемой activity, а ОС запускает его. В неявном интенте вы описываете операцию, которую необходимо выполнить, а ОС запускает activity соответствующего приложения.

* Чтобы сообщить Room, как переводить базу данных с одной версии на другую, нужно добавить свойство **Migration**.

## **Добавление миграции базы данных и предоставление в Room**

```
val migration_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            "ALTER TABLE Crime ADD COLUMN suspect TEXT NOT NULL DEFAULT ''"
        )
    }
}
```

* Так как начальная версия базы данных равна 1, нужно увеличить ее до 2, а затем создать объект Migration, который содержит инструкции по обновлению базы данных.

* **Конструктор класса Migration** принимает два параметра. Первый — это версия базы данных, из которой осуществляется миграция, а второй — версия, в которую осуществляется миграция. В данном случае вводятся номера версий 1 и 2.

* Единственная функция, которую необходимо реализовать в объекте Migration — это **migrate(SupportSQLiteDatabase)**. Вы используете параметр базы данных для выполнения любых SQL-команд, необходимых для обновления таблиц. Команда ALTERTABLE добавляет новый столбец в таблицу преступлений.

* После создания свойства Migration необходимо передать ее в БД. 

* Чтобы настроить миграцию, перед вызовом функции build() вызывается функция **addMigrations(...)**. Функция addMigrations() принимает переменное количество объектов Migration, так что вы можете передать все свои миграции в момент объявления.

* Когда ваше приложение запустится и Room соберет базу данных, оно сначала проверит версию существующей базы данных на устройстве. Если эта версия не соответствует той, которую вы определили в аннотации к базе данных @Database, Room будет искать соответствующие миграции, чтобы обновить базу данных до последней версии.

* Миграция важна для преобразования вашей базы данных. Если вы не укажете миграцию, Room удалит старую версию базы данных и создаст новую версию. Это означает, что все данные будут потеряны, а это приведет к недовольству пользователей.

---

## **Использование неявных интентов**

* Объект Intent описывает для ОС некую операцию, которую вы хотите выполнить. Для явных интентов, использовавшихся до настоящего момента, разработчик явно указывает activity, которую должна запустить ОС

* Для неявных интентов разработчик описывает выполняемую операцию, а ОС запускает activity, которая ранее сообщила о том, что она способна выполнять эту операцию. Если ОС находит несколько таких activity, пользователю предлагается выбрать нужную.

---

## **Строение неявного интента**

* Ниже перечислены важнейшие составляющие интента, используемые для определения выполняемой операции.
    * **Выполняемое действие (action)**. 
    Обычно определяется константами из класса Intent. Так, для просмотра URL-адреса используется константа Intent.ACTION_VIEW, а для отправки данных — константа Intent.ACTION_SEND.

    * **Местонахождение данных**. 
    Это может быть как ссылка на данные, находящиеся за пределами устройства (скажем, URL веб-страницы), так и URI файла или URI контента, ссылающийся на запись ContentProvider.

    * **Тип данных, с которыми работает действие**.
    Тип MIME (например, text/html или audio/mpeg3). Если в интент включено местонахождение данных, то тип обычно удается определить по этим данным.

    * **Необязательные категории**.
    Если действие указывает, что нужно сделать, категория обычно описывает, где, когда или как вы пытаетесь использовать операцию. Android использует категорию android.intent.category.LAUNCHER для обозначения activity, которые должны отображаться в лаунчере приложений верхнего уровня. С другой стороны, категория android.intent.category.INFO обозначает activity, которая выдает пользователю информацию о пакете, но не отображается в лаунчере.

* Например, простой неявный интент для просмотра веб- сайта включает действие Intent.ACTION_VIEW и объект данных Uri с URL-адресом сайта. Activity сообщает о себе как об исполнителе для ACTION_VIEW при помощи фильтра интентов в манифесте. Например, если вы пишете приложение-браузер, вы включаете следующий фильтр интентов в объявление activity, реагирующей на ACTION_VIEW.

```
<activity
   android:name=".BrowserActivity"
   android:label="@string/app_name" >
   <intent-filter>
        <action
            android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT"/>
        <data android:scheme="http" android:host="www.bignerdranch.com" />
    </intent-filter>
</activity>
```

* Категория DEFAULT должна явно задаваться в фильтрах интентов. **Элемент action в фильтре интентов сообщает ОС, что activity способна выполнять операцию, а категория DEFAULT — что она желает рассматриваться среди кандидатов на выполнение операции**. Категория DEFAULT неявно добавляется к почти любому неявному интенту. (Единственное исключение составляет категория LAUNCHER, с которой мы будем работать в главе 23.)

* Неявные интенты, как и явные, также могут включать дополнения. Однако дополнения неявного интента не используются ОС для поиска соответствующей activity.

```
Intent(Intent.ACTION_SEND).apply {
    type = "text/plain"
    putExtra(Intent.EXTRA_TEXT, getCrimeReport())
    putExtra(
        Intent.EXTRA_SUBJECT,
        getString(R.string.crime_report_subject)
    )
}.also { intent ->  
    startActivity(intent)
}
```

* Здесь мы используем конструктор Intent, который получает строку с константой, описывающей действие. Также существуют другие конструкторы, которые могут использоваться в зависимости от вида создаваемого неявного интента. Информацию о них можно найти в справочной документации Intent. Конструктора, получающего тип, не существует, поэтому мы задаем его явно.

* Текст отчета и строка темы включаются в дополнения. Обратите внимание на использование в них констант, определенных в классе Intent. Любая activity, реагирующая на интент, знает эти константы и то, что следует делать с ассоциированными значениями.

* Запуск activity из фрагмента работает почти так же, как и запуск activity из другой activity. Вы вызываете функцию startActivity(Intent) фрагмента, которая вызывает соответствующую функцию Activity.

* Часто лучшим вариантом оказывается использование приложения по умолчанию, выбранного пользователем для действия ACTION_SEND. Впрочем, в приложении CriminalIntent лучше всегда предоставлять пользователю выбор: сегодня пользователь предпочтет не поднимать шум и отправит отчет по электронной почте, а завтра выставит нарушителя на общественное осуждение в «Твиттере».

* Вы можете создать список, который будет отображаться каждый раз при использовании неявного интента для запуска activity. После создания неявного интента способом, показанным ранее, вы вызываете функцию Intent.createChooser(Intent,String) и передаете ей неявный интент и строку с выбранным заголовком. Затем вы передаете интент, возвращенный функцией createChooser(...), в startActivity(...).

---

## **Запрос контакта у Android и получение данных из адресной книги**

* Теперь мы создадим другой неявный интент, который предлагает пользователю выбрать подозреваемого из адресной книги. Для этого неявного интента будет определено действие и местонахождение соответствующих данных. **Действие задается константой Intent.ACTION_PICK, а местонахождение данных — ContactsContract.Contacts.CONTENT_URI**. Короче говоря, вы просите Android помочь с выбором записи из базы данных контактов.

* Запущенная activity должна вернуть результат, поэтому мы передаем интент через startActivityForResult(...) вместе с кодом запроса.

```
val pickContactIntent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI)
setOnClickListener {
    startActivityForResult(pickContactIntent, REQUEST_CONTACT)
}
```

* Теперь необходимо получить результат от приложения адресной книги. Контактная информация совместно используется многими приложениями, поэтому Android предоставляет расширенный API для работы с контактами через ContentProvider. Экземпляры этого класса инкапсулируют базы данных и предоставляют доступ к ним другим приложениям. Обращение к ContentProvider осуществляется через ContentResolver. (Разговор о базе данных контактов — сама по себе обширная тема, и мы не будем обсуждать ее здесь. Если вы хотите узнать больше, ознакомьтесь с руководством по API Content Provider по адресу developer.android.com/guide/topics/providers/content-provider-basics.)

* В onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) создается запрос всех отображаемых имен контактов в возвращенных данных. Затем вы запрашиваете базу данных контактов и получаете объект Cursor, с которым мы работаем. После проверки того, что возвращенный курсор содержит хотя бы одну строку, вы вызываете функцию Cursor.moveToFirst() для перемещения курсора в первую строку. Наконец, вы вызываете функцию Cursor.getString(Int) для перемещения содержимого первого столбца в виде строки. Эта строка будет именем подозреваемого

* Функция onActivityResult(...) вызывается перед onViewCreated(...)

```
val packageManager: PackageManager = requireActivity().packageManager
val resolvedActivity: ResolveInfo? = packageManager.resolveActivity(pickContactIntent, PackageManager.MATCH_DEFAULT_ONLY)
if (resolvedActivity == null) {
    isEnabled = false
}
```

* PackageManager известно все о компонентах, установленных на устройстве Android, включая все его activity. (Другие компоненты встретятся вам позднее в этой книге.) Вызывая resolveActivity(Intent,int), вы приказываете найти activity, соответствующую переданному интенту. Флаг MATCH_DEFAULT_ONLY ограничивает поиск activity с флагом CATEGORY_DEFAULT (по аналогии с startActivity(Intent)).

* Если поиск прошел успешно, возвращается экземпляр ResolveInfo, который сообщает полную информацию о найденной activity. С другой стороны, если поиск вернул null, все кончено — приложения адресной книги нет, поэтому бесполезная кнопка просто блокируется.