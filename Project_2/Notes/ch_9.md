# 9. Вывод списков и RecyclerView

## **Добавление нового фрагмента и ViewModel**

* Хороший метод — создать функцию **newInstance(...)**, которую будут вызывать ваши activity, чтобы получить экземпляр вашего фрагмента. Это похоже на функцию newIntent(), которую использовали в приложении GeoQuiz.

---

## **Жизненный цикл ViewModel с фрагментами**

* ViewModel будет оставаться активным, пока виджет фрагмента находится на экране. ViewModel сохраняется при повороте **(даже если экземпляр фрагмента не сохраняется)** и будет доступен для нового экземпляра объекта.

* ViewModel уничтожается после уничтожения фрагмента. Это может произойти, когда пользователь нажимает кнопку «Назад», закрывая экран. Это также может произойти, если хост-activity заменяет фрагмент на другой. Хотя на экране отображается та же activity, и фрагмент, и связанный с ним ViewModel будут уничтожены, так как они больше не нужны.

* Есть один частный случай — это когда вы добавляете транзакцию проекта обратно в стек. **Когда activity заменяет текущий фрагмент другим, а транзакция возвращается в стек, фрагмент и его ViewModel уничтожены не будут**. Если пользователь нажимает кнопку «Назад», транзакция фрагмента восстанавливается. Оригинальный экземпляр фрагмента помещается обратно на экран, и все данные ViewModel сохраняются.

---

## **Добавление RecyclerView**

* RecyclerView не отображает элементы на самом экране. Он передает эту задачу объекту **LayoutManager**. LayoutManager располагает каждый элемент, а также определяет, как работает прокрутка. Поэтому если RecyclerView пытается сделать что-то подобное при наличии LayoutManager, он сломается.

* RecyclerView является подклассом **ViewGroup**. Он отображает список дочерних объектов View, называемых **представлениями элементов**. Это один объект из списка данных представления — **утилизатор** (в нашем случае одно преступление из списка преступлений). В зависимости от сложности эти дочерние представления могут отображаться сложнее или проще.

![RecyclerView with views](./res/rv_with_views.png)

---

## **Реализация ViewHolder**

* RecyclerView ожидает, что элемент представления будет обернут в экземпляр ViewHolder. **ViewHolder** хранит ссылку на представление элемента (а иногда и ссылки на конкретные виджеты внутри этого представления).

* В конструкторе CrimeHolder мы берем представление для закрепления. Вы сразу же передаете его в качестве аргумента в конструктор классов RecyclerView.ViewHolder. Базовый класс ViewHolder будет закрепляться на свойство под названием itemView.

![ViewHolder with itemView](./res/vh_with_itemView.png)

* RecyclerView никогда не создает объекты View сам по себе. Он всегда создает ViewHolder, которые выводят свои itemView

![RecyclerView with ViewHolder](./res/rv_with_vh.png)

---

## **Реализация адаптера для заполнения RecyclerView**

* Класс RecyclerView не создает ViewHolder сам по себе. Вместо этого используется **адаптер**. Адаптер представляет собой объект контроллера, который находится между RecyclerView и наборами данных, которые отображает RecyclerView.

* Адаптер выполняет следующие функции:

    * создание необходимых ViewHolder по запросу;

    * связывание ViewHolder с данными из модельного слоя.

* Утилизатор выполняет следующие функции:

    * запрашивает адаптер на создание нового ViewHolder;

    * запрашивает адаптер привязать ViewHolder к элементу данных на этой позиции.

* Функция **Adapter.onCreateViewHolder(...)** отвечает за создание представления на дисплее, оборачивает его в холдер и возвращает результат. Если вы делаете что-то интересное вроде отображения различных типов представлений в одно представление утилизатора, вам нужны только эти значения параметров onCreateViewHolder(...).

* Функция
**Adapter.onBindViewHolder(holder:CrimeHolder,positi on:Int)** отвечает за заполнение данного холдера holder данными из данной позиции position. В этом случае данные из списка преступлений окажутся в нужной позиции.

* Функция **getItemCount()** возвращает количество элементов в списке преступлений, отвечая на запрос утилизатора. Когда утилизатору нужно знать, сколько элементов в наборе данных поддерживают его (например, когда он впервые создается), он будет просить свой адаптер вызвать Adapter.getItemCount().

![Adapter](./res/adapter.png)

* Когда утилизатору требуется объект для отображения, он запрашивает адаптер.

![Adapter with RecyclerView](./res/adapter_with_rv.png)

* При резкой прокрутке анимация должна идти как по маслу. Этот эффект — прямое следствие того, что событие onBindViewHolder(...) выполняет лишь минимальный объем работы. Отсюда вывод: событие onBindViewHolder(...) всегда должно быть эффективно. В противном случае анимация будет выглядеть не как по маслу, а как по засушенному твердому пармезану.

---

## **Переработка представлений**

* RecyclerView делает именно это. Вместо того чтобы создать 100 объектов View, он создает их столько, сколько нужно для заполнения экрана. Когда представление пропадает с экрана, RecyclerView использует его заново, а не выбрасывает. Тем самым он оправдывает свое название — перерабатывает объекты.

* В связи с этим функция onCreateViewHolder(ViewGroup,Int) будет вызываться намного реже, чем onBindViewHolder(ViewHolder,Int). Когда создано достаточно объектов ViewHolder, RecyclerView перестает вызывать onCreateViewHolder(...). Вместо этого он экономит время и память путем утилизации старых объектов ViewHolder и передает их в onBindViewHolder(ViewHolder,Int).

---

## **Очистка элементов связанного списка**

* В данный момент в приложении Adapter привязывает данные преступления непосредственно к текстовым виджетам в функции Adapter.onBindViewHolder(...). Это работает отлично, но лучше более четко разделить задачи между холдером и адаптером. Адаптер должен знать как можно больше о внутренней кухне и данных холдера. 

* Затем в приложении мы вызываем новоиспеченную функцию bind(Crime) всякий раз, когда RecyclerView запрашивает привязку CrimeHolder к конкретному преступлению.

---

## **ListView и GridView**

* Ядро Android OS включает классы ListView, GridView и Adapter. До выхода Android 5.0 это были предпочтительные способы создания списков или сеток элементов. API для этих компонентов очень похожи на RecyclerView. Класс ListView или GridView отвечает за прокрутку набора элементов, но не располагает информацией об этих элементах. Адаптер отвечает за создание каждого из изображений в списке. Однако ListView и GridView не заставляют вас использовать шаблон ViewHolder (хотя вы можете и должны делать это).

* Эти старые реализации заменены реализацией RecyclerView из-за сложности изменения поведения ListView или GridView.

* Создание горизонтальной прокрутки ListView, например, не входит в ListView API и требует много работы. Создание пользовательского макета и прокрутки с помощью RecyclerView — тоже непростая задача, но RecyclerView лучше для нее предназначен.

* Еще одна ключевая особенность RecyclerView — анимация элементов в списке. Анимированное добавление или удаление элементов — это сложная задача, в которой легко допустить ошибку. RecyclerView делает процесс намного проще, имеет несколько встроенных анимаций и позволяет легко настраивать их.